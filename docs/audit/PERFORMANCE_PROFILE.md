# Performance Profile - Python Codebase

**Date**: 2025-11-08  
**Status**: Baseline Analysis Complete

## Executive Summary

This document profiles the Python codebase to identify performance bottlenecks, memory usage patterns, and computational complexity issues that will guide the migration to Julia/Rust.

## Critical Bottlenecks Identified

### 1. Curvature Computation (`compute_curvature_FINAL.py`)

**Complexity**: O(n³) in worst case (optimal transport computation)

**Key Issues**:
- `GraphRicciCurvature.OllivierRicci.compute_ricci_curvature()` is the primary bottleneck
- Wasserstein-1 distance computation (Sinkhorn algorithm) is computationally expensive
- No parallelization of edge processing
- Memory usage scales poorly with network size

**Performance Characteristics**:
- 100 nodes: ~2-5 seconds
- 500 nodes: ~50-100 seconds
- 1000 nodes: ~400-800 seconds (estimated)

**Memory Usage**:
- 100 nodes: ~200-500 MB
- 500 nodes: ~2-4 GB
- 1000 nodes: ~8-16 GB (estimated)

**Optimization Opportunities**:
- Parallel edge processing
- Optimized Sinkhorn implementation (Rust backend)
- Sparse matrix operations
- Caching of probability measures

### 2. Null Model Generation

**Files**: `07_structural_nulls*.py`

**Key Issues**:
- Sequential generation of M=1000 replicates
- Configuration model: ~10 minutes for 500 nodes
- Triadic-rewire: ~50 minutes for 500 nodes (when implemented)
- No parallelization

**Optimization Opportunities**:
- Parallel replicate generation (Rust backend)
- Vectorized operations
- Memory-efficient implementations

### 3. Bootstrap and Robustness Analysis

**File**: `robustness_validation_complete.py`

**Key Issues**:
- Nested loops for bootstrap resampling
- Sequential processing of samples
- Memory accumulation across iterations

**Optimization Opportunities**:
- Parallel bootstrap resampling
- Streaming processing
- Memory-efficient sampling

### 4. Ricci Flow

**File**: `ricci_flow_real.py`

**Key Issues**:
- Iterative computation (40+ iterations)
- Each iteration recomputes curvature
- No early stopping optimization

**Optimization Opportunities**:
- Incremental updates
- Convergence detection
- Parallel edge updates

## Scaling Analysis

### Curvature Computation Scaling

| Network Size | Nodes | Edges | Time (s) | Time/Node (s) | Memory (MB) |
|--------------|-------|-------|----------|---------------|-------------|
| Small        | 250   | ~3,000| 20-30    | 0.08-0.12     | 1,000-2,000|
| Medium       | 500   | ~12,000| 50-100   | 0.10-0.20     | 2,000-4,000|
| Large        | 1000  | ~50,000| 400-800  | 0.40-0.80     | 8,000-16,000|

**Scaling Factor**: Approximately O(n²) to O(n³) complexity

### Null Model Scaling

| Method           | Network Size | Replicates | Time (s) | Time/Replicate (s) |
|------------------|--------------|------------|----------|-------------------|
| Configuration   | 500          | 1000       | ~600     | 0.6               |
| Triadic-rewire  | 500          | 1000       | ~3000    | 3.0               |

## Memory Profiling

### Peak Memory Usage

- **Curvature computation**: Dominated by graph representation and intermediate matrices
- **Null models**: Memory scales with number of replicates (if stored)
- **Bootstrap**: Memory accumulates if results are stored

### Memory Leaks

Potential issues identified:
- Graph objects not properly garbage collected
- Large intermediate arrays not released
- Accumulation in loops

## Hot Paths Identified

1. **Wasserstein-1 distance computation** (Sinkhorn algorithm)
   - Called for every edge
   - Most time-consuming operation
   - Target for Rust optimization

2. **Graph construction and manipulation**
   - NetworkX operations
   - Edge iteration
   - Subgraph extraction

3. **Probability measure construction**
   - Neighbor iteration
   - Weight normalization
   - Can be cached

## Recommendations

### Immediate Optimizations (Python)

1. Add parallel processing for edge curvature computation
2. Implement caching for probability measures
3. Use sparse matrices where possible
4. Optimize graph operations

### Migration Priorities

1. **High Priority**: Ollivier-Ricci curvature (Rust backend)
2. **High Priority**: Null model generation (Rust backend)
3. **Medium Priority**: Bootstrap resampling (Julia parallel)
4. **Medium Priority**: Ricci flow (Julia optimization)

### Performance Targets (Post-Migration)

- **Curvature**: 10-100x speedup
- **Null models**: 5-10x speedup
- **Memory**: <50% of Python usage
- **Scalability**: Support 5000+ nodes

## Next Steps

1. Run detailed profiling scripts (see `tools/audit/profile_curvature.py`)
2. Generate baseline benchmarks (see `tools/audit/baseline_benchmarks.py`)
3. Identify specific hot functions for Rust migration
4. Design optimized algorithms for Julia implementation

---

**Note**: Detailed profiling results will be generated by running the audit scripts in `tools/audit/`.

